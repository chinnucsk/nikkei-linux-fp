並列プログラミング版 N Queens の解説
====================================

作成者：河野 達也 / Tatsuya Kawano、CloudianKK

最終更新：2012年9月4日

目次
----

1. はじめに
2. 並列プログラミング版 N Queens の概要
3. マルチコアCPUで実行する
4. 複数のマシンで分散実行する
5. コードの解説


1. はじめに
-----------

- 本書および関連するプログラムは、日経Linux 2012年10月号 特集1 「Linuxで楽々アプリ開発超入門 − Part 4 Erlang & Haskell」の付録です。理解をより深めるために、ぜひ日経Linux 2012年10月号の特集記事をお読みください。

- ウェブブラウザで以下のURLを開くと読みやすく整形された本書が表示されます。
  * https://github.com/tatsuya6502/nikkei-linux-fp/blob/master/erlang/dist_qu/README.md


2. 並列プログラミング版 N Queens の概要
---------------------------------------

　このディレクトリ `nikkei-linux-fp/erlang/dist_qu/` には、並列プログラミング版のN Queensプログラムが収められています。

　特集記事内で作成したオリジナルのN Queensプログラムは、逐次処理（シングルスレッド）プログラムとして書かれています。マルチコアCPUを搭載したコンピュータで実行しても1つのコアしか活用できず、本来の性能を生かせません。

　一方、この並列プログラミング版では、処理を小分けにしマルチスレッドで同時に処理させることで、CPUの全てのコアを活用できます。さらに、多数のコンピュータを協調させて動作させる「分散コンピューティング」にも対応していますので、コンピュータの台数を増やすことで、N Queensの解を求めるまでの時間を短縮できます。

　言語はErlangを使用しました。従来のプログラミング技法では、並列プログラムを書くには高度な知識と経験が必要です。しかし、Erlangでは「アクターベースのメッセージ交換」というモデルを採用しており、驚くほど簡単に、バグのない並列プログラムが書けます。

　またErlangには「軽量プロセス」という仕組みがあります。軽量プロセスはErlangの仮想マシン内で独自に実装されたスレッドです。Linuxが提供するOSレベルのスレッドに依存しないため、並列プログラムの性能を劣化させる「コンテキスト・スイッチ」が起こらず、軽快に動作します。最近のコンピュータなら数十万個起動しても問題なく動作するでしょう。なおほとんどの言語では並列化の部品を「スレッド」と呼びますが、Erlangではアクターモデルによりスレッド間で共有メモリーを持たないことから「プロセス」と呼びます。

　本書では並列プログラミング版N Queensプログラムの実行方法を解説し、筆者の環境での実行時間を報告します。またコードの内容も簡単に説明します。


3. マルチコアCPUで実行する
--------------------------

　まずは1台のコンピュータで実行しましょう。並列プログラミングによる高速化を体験するためには2つ以上のコアを持つCPUが必要です。

　ターミナルを開き、`erlc`コマンドでErlangプログラムをコンパイルします。（□のマークで改行）

```shell
$ cd ~/nikkei-linux-fp/erlang/dist_qu □
$ erlc *.erl □
```

　Erlang仮想マシンを起動し、N Queensの解を求めます。まずは試しにオリジナルのシングルスレッド版を実行しましょう。`length`関数で解の数だけを表示し、さらに`timer:tc`関数で実行時間を測定します。

```erlang
$ erl □
1> length(qu:queens(8)).  □
92
2> timer:tc(fun() -> length(qu:queens(8)) end). □
{98473,92}
```

　1つ目の数字が実行時間で、単位はマイクロ秒です。2つ目の数字は`length`の戻り値で、8 queensの解の数が92個であることを表しています。

　次に並列プログラミング版を実行しましょう。`dist_`は「distributed」の略で、分散処理（distributed computing）の「分散」を表します。

```erlang
3> timer:tc(fun() -> length(dist_qu:queens(8)) end). □
Started 56 workers.
{29883,92}
```

　`Started 56 workers`のメッセージで、56個のプロセスが起動したことが分かります。プロセス数はNに応じて変化します。

　N = 8ではすぐに終わっていまいますので、少し大きな数字で実行してみてください。筆者の環境でN = 12で実行した時の結果を以下に示します。なお筆者は今回 Amazon AWSの仮想サーバーサービス「EC2」を使用しました。インスタンスタイプに`c1.xlarge`を選び、OSはUbuntu 12.04.1 LTS Serverにしました。c1.xlargeには8個の仮想CPUコアと、7Gバイトのメモリーが搭載されています。

　シングルスレッド版と並列プログラミング版を交互に2回ずつ実行しました。

```erlang
4> timer:tc(fun() -> length(qu:queens(12)) end). □
{1920578890,14200}
5> timer:tc(fun() -> length(dist_qu:queens(12)) end). □
Started 132 workers.
{542088258,14200}
6> timer:tc(fun() -> length(qu:queens(12)) end). □
{1921167187,14200}
7> timer:tc(fun() -> length(dist_qu:queens(12)) end). □
Started 132 workers.
{542463027,14200}
```

　1コアでは平均32分00秒、8コアでは平均9分02秒となりました。8コアの実行速度は1コアで実行した時の3.5倍です。

　8コアなので8倍近い差がついてほしいところですが、残念ながらそうはなりませんでした。実行中に`top`コマンドでerl仮想マシンのCPU使用率を観察すると、799%〜800%と表示されますので、8コアの能力を使い切っていることは間違いなさそうです。あくまでも推測ですが、RAMへのアクセス速度がボトルネックになっているのかもしれません。

　8倍には及ばないものの、マルチコアで性能が向上することは確認できました。次の章で説明するように、コンピュータの台数を増やすことで性能を直線的に向上させられますので、コア数あたりの性能にこだわる理由はあまりなさそうです。Erlangでは高品質な並列プログラムが驚くほど簡単に書けますので、ほとんどのアプリケーションでは、その開発生産性を生かすほうが利益が大きいでしょう。もし性能に不満があれば、コンピュータの台数を増やすことで解決できます。


4. 複数のマシンで分散実行する
-----------------------------

　次に多数のコンピュータを協調させてN Queensの解を求めます。プログラムは先ほどの並列プログラミング版がそのまま使えます。

　まずは準備です。協調して動作させたいそれぞれのコンピュータで、Erlang仮想マシンのマジッククッキー文字列を設定します。クッキーはネットワーク通信用のパスワードで、同じクッキーを持つErlang仮想マシン間では、プロセスがネットワーク越しにメッセージを交換できます。

```shell
$ chmod 600 ~/.erlang.cookie □
$ echo "very secret" > ~/.erlang.cookie □
$ chmod 400 ~/.erlang.cookie □
```

　この例ではマジッククッキーを`very secret`に設定しましたが、実運用ではもっと推測しにくい文字列に設定することをお勧めします。文字数の制限はありません。

　`dist_qu`ディレクトリのErlangプログラムをコンパイルします。以下のコマンドを全てのコンピュータで実行してください。

```shell
$ cd ~/nikkei-linux-fp/erlang/dist_qu □
$ erlc *.erl □
```

　準備ができたのでErlang仮想マシンを起動しましょう。起動時に短縮名（sname）を指定起動します。またTCP/IPによる通信の並列性を高めるために、`+A`オプションで非同期スレッドを起動します。

　Erlang仮想マシンは全てのコンピュータで実行してください。筆者は3台のEC2仮想コンピュータを使用しました。

```shell
（1台目のコンピュータ）
$ cd ~/nikkei-linux-fp/erlang/dist_qu □
$ erlc *.erl □
$ erl -sname node1 +A8 □
Erlang R14B04 (erts-5.8.5) [source] [64-bit] [smp:8:8] [rq:8] [async-threads:8] [hipe] [kernel-poll:false]

Eshell V5.8.5  (abort with ^G)
(node1@ip-10-39-74-148)1>

（2台目のコンピュータ）
$ cd ~/nikkei-linux-fp/erlang/dist_qu □
$ erlc *.erl □
$ erl -sname node2 +A8 □
（省略）
(node2@ip-10-35-6-185)2>

（3台目のコンピュータ）
$ cd ~/nikkei-linux-fp/erlang/dist_qu □
$ erlc *.erl □
$ erl -sname node3 +A8 □
（省略）
(node3@ip-10-119-127-146)>1
```

　erlシェルのプロンプトを見ると、仮想マシンに`node1@ip-10-39-74-148`のような名前（ノード名）が付いたことが分かります。このようにノード名は、`snameで指定した名前`＋`コンピュータのホスト名`になります。ノード名はネットワーク上でユニークでなければいけませんが、ホスト名で修飾されるので、本当はわざわざ`node1`、`node2`、`node3`のようにsnameを変える必要はありません。ただ筆者にはこの方が分かりやすいので、こうしています。

　なお1台のコンピュータで複数の仮想マシンを稼働させることも可能です。その場合はsnameが重複しないようにしてください。

　ノード名はerlシェルのプロンプトに表示されますが、`node`関数で調べられます。

```erlang
(node1@ip-10-39-74-148)2> node(). □
'node1@ip-10-39-74-148'
```

　次に仮想マシン間で通信ができることを確認しましょう。`net_adm:ping`関数を使います。

```erlang
(node1@ip-10-39-74-148)3> net_adm:ping('node2@ip-10-35-6-185'). □
pong
(node1@ip-10-39-74-148)4> net_adm:ping('node3@ip-10-119-127-146'). □
pong
```

　このように`pong`と表示されればOKです。

　もし接続できない場合は`pang`と表示されます。その場合は以下の点を確認してください。

1. ノード名が間違っていないか確認する。各仮想マシンのerlシェルで `node().` を実行します
2. マジッククッキーが全てのコンピュータで同一であることを確認する
3. ファイアウォールでErlangが使用するポートを開ける

Erlang仮想マシンが使用するポートは2種類あります。1種類目はポート4369で、ポートの割り当てを管理する`epmd`（Erlang Port Mappter Daemon）が使用します。2種類目は仮想マシン間の通信に使うポートで動的に割り当てられます。`inet_dist_listen_*`パラメータで、使用するポートの範囲を制限できます。

```shell
（例、ポート6000から6099を使う場合）
$ erl -sname nodeX +A8 -kernel inet_dist_listen_min 6000 inet_dist_listen_max 6099 □
```

　仮想マシン間で通信できることが確認できたら、N Queensプログラムを実行しましょう。`dist_qu:queens`関数の第2引数にノード名のリストを与えます。

```erlang
(node1@ip-10-39-74-148)5> timer:tc(fun() -> length(dist_qu:queens(12, ['node1@ip-10-39-74-148','node2@ip-10-35-6-185','node3@ip-10-119-127-146'])) end). □
Started 132 workers.
{166041557,14200}
(node1@ip-10-39-74-148)6> timer:tc(fun() -> length(dist_qu:queens(12, ['node1@ip-10-39-74-148','node2@ip-10-35-6-185','node3@ip-10-119-127-146'])) end). □
Started 132 workers.
{166034698,14200}
```

　3台24コアでは平均2分46秒でした。実行速度は1台8コアの3.3倍、1台1コアの11.6倍です。実行速度が台数に比例して向上することが確認できました。


5. コードの解説
---------------

　並列プログラミングに必要なコードは `dist_qu.erl` に書かれています。コードの量は行数にして30行弱です。

　`dist_qu.erl`で最初に呼ばれるのは`queens`関数です。

```erlang
queens(N) ->
    queens(N, []).

queens(N, Nodes) when N >= 4 ->
    Seed = seq(1, N),                       % ← (1)
    Prefixes = qu_math_perm:all(Seed, 2),   % ← (2)
    Ref = erlang:make_ref(),
    Pids = start_workers(Seed, Prefixes, self(), Ref, Nodes),   % ← (3)
    io:format("Started ~p workers.~n", [length(Pids)]),
    gather_results(Pids, Ref).              % ← (4)
```

　(1)で1からNまでの数列を作ります。(2)で駒の配置を小分けにし、(3)では`dist_qu`内で定義されている別の関数`start_workers`を呼んで多数の軽量プロセスを起動します。ここではこれらのプロセスをワーカーと呼ぶことにします。(4)では`dist_qu`内で定義されている別の関数`gather_results`を呼んで、ワーカープロセスが見つけた解を収集します。

　もうすこし細かく見ていきましょう。erlシェルを起動し、N = 5のケースで、(1)と(2)に相当する部分を実行します。

```erlang
$ erl
1> N = 5.
5
2> Seed = lists:seq(1, N).
[1,2,3,4,5]
3> Prefixes = qu_math_perm:all(Seed, 2).
[[1,2],
 [1,3],
 [1,4],
 [1,5],
 [2,1],
 [2,3],
 [2,4],
 [2,5],
 [3,1],
 [3,2],
 [3,4],
 [3,5],
 [4,1],
 [4,2],
 [4,3],
 [4,5],
 [5,1],
 [5,2],
 [5,3],
 [5,4]]
```

　`qu_math_perm`モジュールは`qu_math:permutations`関数の機能追加版です。`qu_math_perm:all(Seed, 2)`とすると、Seedの全ての組み合わせを返すのではなく、Seedの中から一度に2つの数字をだけを使って組み合わせを作ります。

　`start_worker`関数ではここで作った組み合わせの数だけワーカープロセスを起動します。

```erlang
start_workers(Seed, Prefixes, Self, Ref, []) ->
    map(fun(Prefix) -> spawn_link(?MODULE, run_queens, [Self, Ref, Prefix, Seed -- Prefix]) end, % ← (1)
        Prefixes);
start_workers(Seed, Prefixes, Self, Ref, Nodes) ->
    {_, Pids} = foldl(fun(Prefix, {I, Ps}) ->
                              Node = lists:nth(I rem length(Nodes) + 1, Nodes),
                              Pid = spawn_link(Node, ?MODULE, run_queens, [Self, Ref, Prefix, Seed -- Prefix]),
                              {I + 1, [Pid | Ps]}
                      end, {1, []}, Prefixes),
    reverse(Pids).
```

　`start_worker`関数は2種類定義されています。1つ目は1台のコンピュータで実行する時のもの、2つ目は複数のコンピュータで実行する時のものです。

　`spawn_link`はErlang組み込みの関数です。軽量プロセスを起動し、指定した関数を実行させます。たとえば(1)で書かれているように

```erlang
spawn_link(?MODULE, run_queens, [Self, Ref, Prefix, Seed -- Prefix])
```

なら、プロセスが実行する関数は、

```erlang
dist_qu:run_queens(Self, Ref, Prefix, Seed -- Prefix)
```

になります。`spawn_link`の戻り値は、起動したプロセスのプロセスID（PID）です。

　2つ目の`start_worker`関数にはプロセスを実行するノードを選ぶためのコードが追加されています。`spawn_link`では第1引数でノード名を与えています。

```erlang
spawn_link(Node, ?MODULE, run_queens, [Self, Ref, Prefix, Seed -- Prefix])
```

　`Self`と`Ref`はワーカープロセスから結果を受けとる時に使います。残りの引数はワーカープロセスが`queens`を呼ぶ時に使います。`Seed -- Prefix`は`Seed`リストから`Prefix`リストの要素を取り除いたリストを返します。

　`Prefix`と`Seed -- Prefix`が実際にどのような値になるか見てみましょう。

```erlang
3> lists:map(fun(Prefix) -> {Prefix, Seed -- Prefix} end, Prefixes).
[{[1,2],[3,4,5]},
 {[1,3],[2,4,5]},
 {[1,4],[2,3,5]},
 {[1,5],[2,3,4]},
 {[2,1],[3,4,5]},
 {[2,3],[1,4,5]},
 {[2,4],[1,3,5]},
 {[2,5],[1,3,4]},
 {[3,1],[2,4,5]},
 {[3,2],[1,4,5]},
 {[3,4],[1,2,5]},
 {[3,5],[1,2,4]},
 {[4,1],[2,3,5]},
 {[4,2],[1,3,5]},
 {[4,3],[1,2,5]},
 {[4,5],[1,2,3]},
 {[5,1],[2,3,4]},
 {[5,2],[1,3,4]},
 {[5,3],[1,2,4]},
 {[5,4],[1,2,3]}]
```

　次は`run_queens`関数です。

```erlang
run_queens(Parent, Ref, Prefix, Rest) ->
    Parent ! {self(), Ref, (catch qu:queens(Prefix, Rest))}.
```

　`qu:queens(Prefix, Rest)`はオリジナルの`queens`の拡張版で、Nの全ての駒の配置を検査するのではなく、一部の配置だけを検査します。オリジナルの`queens`ではN = 5なら`[1,2,3,4,5]`の数列を作り`permutations`関数を適用しました。一方、拡張版の`queens`では`Rest`に束縛された数列（例、`[3,4,5]`）に`permutations`関数を適用し、その先頭に`Prefix`に束縛された数列（例、`[1,2]`）を追加します。

　`run_queens`が引数として`Prefix = [1,2]`、`Rest = [3,4,5]`を取った時に検査する駒の配置は以下の6種類になります。

```erlang
4> Boards = qu_math_perm:all([3,4,5]).
[[3,4,5],[3,5,4],[4,3,5],[4,5,3],[5,3,4],[5,4,3]]
5> lists:map(fun(Board) -> [1,2] ++ Board end, Boards).
[[1,2,3,4,5],
 [1,2,3,5,4],
 [1,2,4,3,5],
 [1,2,4,5,3],
 [1,2,5,3,4],
 [1,2,5,4,3]]
```

　`run_queens`の`Parent ! { ... }`ではプロセス間のメッセージ送信を使い、ワーカープロセスから`start_workers`を実行した親プロセスへ`qu:queens`関数の結果を返しています。`Parent`変数には親プロセスのプロセスIDが束縛されており、`!`はその親プロセスへ`!`の後ろで与えたタプルを送信します。

　タプルの内容は

`{ワーカープロセスのpid, 親からもらったRef変数の値, qu:queens関数の結果}`

です。送信されたメッセージは親プロセスのメッセージボックスに溜まります。

　最後は`gather_results`関数です。この関数は親プロセスが実行し、ワーカープロセスが返してきた`qu:queens`関数の結果を1つにまとめます。

```erlang
gather_results(Pids, Ref) ->
    foldl(fun(Pid, Acc) ->
                  receive
                      {Pid, Ref, Result} -> Result ++ Acc
                  end
          end, [], Pids).
```

　`lists:foldl`関数は「畳み込み」と呼ばれ、第3引数で与えられたワーカープロセスのプロセスIDのリストの各要素に、第1引数のラムダ式を適用します。第2引数はアキュムレーターと呼ばれ、初期値として空リストを渡しています。アキュムレーターには第1引数の関数が返す結果が蓄積されていきます。

　ラムダ式では第1引数にワーカープロセスのプロセスIDが束縛され、第2引数にアキュムレーターが束縛されます。`recieve`文を使いメールボックスに溜まったメッセージの中から`Pid`と`Ref`が一致するものを取り出し、`qu:queens`関数の結果を`Result`変数に束縛します。最後に`++`で`Result`リストをアキュムレーターに追加します。

　`foldl`関数が終了するとアキュムレーターの値が返されます。そこにはN Queensの全ての解が蓄積されています。

##
